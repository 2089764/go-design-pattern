# 单例模式(Singleton Design Pattern)

单例模式采用了 饿汉式 和 懒汉式 两种实现，个人其实更倾向于饿汉式的实现，简单，并且可以将问题及早暴露，懒汉式虽然支持延迟加载，但是这只是把冷启动时间放到了第一次使用的时候，并没有本质上解决问题，并且为了实现懒汉式还不可避免的需要加锁

- 定义：一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式
- 用处：从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类
- 单例模式的唯一性
  - 进程间唯一
  - 如何实现线程间唯一？
    - 通过获取线程id
    - 在golang中无法使用，golang主要使用协程，并且协程的id并没有暴露出来
  - 如何实现集群环境之间唯一？（多进程）
    - 通过外部共享存储的锁进行。例如文件
- 存在的问题
  - 对OOP的特性支持不友好
  - 减低可读性：通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来
  - 会隐藏类之间的依赖关系
  - 对代码扩展性不友好：如果有一天需要创建多个实例就会比较麻烦
  - 对代码的可测性不友好
    - 单例类是硬编码的模式，不利于mock
    - 如果是可以修改的全局变量，测试的时候还要注意不同测试用例对它的修改可能会有问题
    - 可以通过将单例类作为参数传递给需要使用的方法解决可测性的问题
  - 不支持有参数的构造函数
- 如何实现
  - 构造函数是private访问权限
  - 考虑对象创建时的线程安全问题
  - 考虑是否支持延迟加载
  - 考虑getInstance的性能问题（是否有加锁等）
- 实现方式
  - 饿汉式
    - 类加载的时候instance实例就已经创建好了
    - instance的创建过程是线程安全的
    - 不支持延迟加载
    - 初始化时间可能会比较长
    - 延迟加载不是大问题，启动时慢一些总比用户访问的时候慢一些要好
  - 懒汉式
    - 在getInstance的时候再去创建
    - instance创建过程需要加锁
    - 支持延迟加载
    - 不支持高并发
  - 双重检测
    - 在懒汉式的基础上，将方法的锁改成类级别的锁
    - 相对于懒汉式锁的粒度更小，不会每次都去获取锁
  - 静态内部类
    - 在Java的类中创建一个静态的内部类
    - 线程安全
    - 延迟加载
  - 枚举
    - 利用java的枚举特性